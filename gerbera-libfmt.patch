Not sure what was expected to be printed (`.name()`, `.value()`, `.child_value()`?)
With older libfmt it probably used implicit conversion to bool, but it's unlikely to be wanted.

--- gerbera-1.12.1/src/config/setup/config_setup_autoscan.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_autoscan.cc	2023-07-25 18:33:33.190773810 +0200
@@ -243,7 +243,7 @@ std::shared_ptr<ConfigOption> ConfigAuto
 {
     auto result = std::vector<AutoscanDirectory>();
     if (!createOptionFromNode(optValue, result)) {
-        throw_std_runtime_error("Init {} autoscan failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} autoscan failed '{}'", xpath, optValue.child_value());
     }
     optionValue = std::make_shared<AutoscanListOption>(result);
     return optionValue;
--- gerbera-1.12.1/src/config/setup/config_setup_array.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_array.cc	2023-07-25 18:35:27.616820577 +0200
@@ -137,11 +137,11 @@ std::vector<std::string> ConfigArraySetu
     std::vector<std::string> result;
     if (initArray) {
         if (!initArray(optValue, result, ConfigDefinition::mapConfigOption(nodeOption))) {
-            throw_std_runtime_error("Invalid {} array value '{}'", xpath, optValue);
+            throw_std_runtime_error("Invalid {} array value '{}'", xpath, optValue.child_value());
         }
     } else {
         if (!createOptionFromNode(optValue, result)) {
-            throw_std_runtime_error("Invalid {} array value '{}'", xpath, optValue);
+            throw_std_runtime_error("Invalid {} array value '{}'", xpath, optValue.child_value());
         }
     }
     if (result.empty()) {
@@ -150,7 +150,7 @@ std::vector<std::string> ConfigArraySetu
         result = defaultEntries;
     }
     if (notEmpty && result.empty()) {
-        throw_std_runtime_error("Invalid array {} empty '{}'", xpath, optValue);
+        throw_std_runtime_error("Invalid array {} empty '{}'", xpath, optValue.child_value());
     }
     return result;
 }
--- gerbera-1.12.1/src/config/setup/config_setup_client.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_client.cc	2023-07-25 18:38:46.295744241 +0200
@@ -183,7 +183,7 @@ std::shared_ptr<ConfigOption> ConfigClie
     auto result = std::make_shared<ClientConfigList>();
 
     if (!createOptionFromNode(isEnabled ? optValue : pugi::xml_node(nullptr), result)) {
-        throw_std_runtime_error("Init {} client config failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} client config failed '{}'", xpath, optValue.child_value());
     }
     optionValue = std::make_shared<ClientConfigListOption>(result);
     return optionValue;
--- gerbera-1.12.1/src/config/setup/config_setup_dictionary.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_dictionary.cc	2023-07-25 18:40:20.188568914 +0200
@@ -163,11 +163,11 @@ std::map<std::string, std::string> Confi
     std::map<std::string, std::string> result;
     if (initDict) {
         if (!initDict(optValue, result)) {
-            throw_std_runtime_error("Init {} dictionary failed '{}'", xpath, optValue);
+            throw_std_runtime_error("Init {} dictionary failed '{}'", xpath, optValue.child_value());
         }
     } else {
         if (!createOptionFromNode(optValue, result) && required) {
-            throw_std_runtime_error("Init {} dictionary failed '{}'", xpath, optValue);
+            throw_std_runtime_error("Init {} dictionary failed '{}'", xpath, optValue.child_value());
         }
     }
     if (result.empty()) {
@@ -176,7 +176,7 @@ std::map<std::string, std::string> Confi
         result = defaultEntries;
     }
     if (notEmpty && result.empty()) {
-        throw_std_runtime_error("Invalid dictionary {} empty '{}'", xpath, optValue);
+        throw_std_runtime_error("Invalid dictionary {} empty '{}'", xpath, optValue.child_value());
     }
     return result;
 }
--- gerbera-1.12.1/src/config/setup/config_setup_dynamic.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_dynamic.cc	2023-07-25 18:41:05.124992139 +0200
@@ -192,7 +192,7 @@ std::shared_ptr<ConfigOption> ConfigDyna
     auto result = std::make_shared<DynamicContentList>();
 
     if (!createOptionFromNode(optValue, result)) {
-        throw_std_runtime_error("Init {} DynamicContentList failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} DynamicContentList failed '{}'", xpath, optValue.child_value());
     }
     optionValue = std::make_shared<DynamicContentListOption>(result);
     return optionValue;
--- gerbera-1.12.1/src/config/setup/config_setup_transcoding.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_transcoding.cc	2023-07-25 18:42:14.297950730 +0200
@@ -497,7 +497,7 @@ std::shared_ptr<ConfigOption> ConfigTran
     auto result = std::make_shared<TranscodingProfileList>();
 
     if (!createOptionFromNode(isEnabled ? optValue : pugi::xml_node(nullptr), result)) {
-        throw_std_runtime_error("Init {} transcoding failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} transcoding failed '{}'", xpath, optValue.child_value());
     }
     optionValue = std::make_shared<TranscodingProfileListOption>(result);
     return optionValue;
--- gerbera-1.12.1/src/config/setup/config_setup_tweak.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_tweak.cc	2023-07-25 18:43:05.837671515 +0200
@@ -257,7 +257,7 @@ std::shared_ptr<ConfigOption> ConfigDire
     auto result = std::make_shared<DirectoryConfigList>();
 
     if (!createOptionFromNode(optValue, result)) {
-        throw_std_runtime_error("Init {} DirectoryConfigList failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} DirectoryConfigList failed '{}'", xpath, optValue.child_value());
     }
     optionValue = std::make_shared<DirectoryTweakOption>(result);
     return optionValue;
--- gerbera-1.12.1/src/config/setup/config_setup_vector.cc.orig	2023-01-02 18:11:40.000000000 +0100
+++ gerbera-1.12.1/src/config/setup/config_setup_vector.cc	2023-07-25 18:43:52.497418738 +0200
@@ -181,7 +181,7 @@ std::vector<std::vector<std::pair<std::s
 {
     std::vector<std::vector<std::pair<std::string, std::string>>> result;
     if (!createOptionFromNode(optValue, result) && required) {
-        throw_std_runtime_error("Init {} vector failed '{}'", xpath, optValue);
+        throw_std_runtime_error("Init {} vector failed '{}'", xpath, optValue.child_value());
     }
     if (result.empty()) {
         log_debug("{} assigning {} default values", xpath, defaultEntries.size());
@@ -189,7 +189,7 @@ std::vector<std::vector<std::pair<std::s
         result = defaultEntries;
     }
     if (notEmpty && result.empty()) {
-        throw_std_runtime_error("Invalid vector {} empty '{}'", xpath, optValue);
+        throw_std_runtime_error("Invalid vector {} empty '{}'", xpath, optValue.child_value());
     }
     return result;
 }
